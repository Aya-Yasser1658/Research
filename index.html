<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .part1 h1{
            text-align: center;
            display: flex;
        }
        .part1{
            align-items: center;
            justify-content: center;
            display: flex;
            flex-direction: column;
        }
        .part1 p{
            text-align: center;
            align-items: center;
            justify-content: center;
            display: flex;
            border: 0.2px solid black;
            background-color: rgb(54, 149, 237);
            color: white;
            margin: 50px;
            padding: 30px;
            width: 400px;
            height: 100px;
        }
        
        .part2{
            align-items: center;
            justify-content: center;
            display: flex;
            flex-direction: column;
        }
        .part2 p{
            text-align: center;
            display: flex;
            border: 0.2px solid black;
            background-color: rgb(54, 149, 237);
            color: white;
            margin: 50px;
            padding: 30px;
            width: 600px;
            height: 250px;}
        
        .part2 h1{
            text-align: center;
            display: flex;
        }
    </style>



</head>
<body>
    <div class="part1">
        <h1>ECMAScript6</h1>
        <p>ECMAScript 2015 (commonly known as ES6) introduced several 
            new features and enhancements to JavaScript, 
            significantly improving the language's functionality
            and making it easier to write cleaner and more efficient code</p>
        <div class="main">
            <p>1. Let and Const:<br>
                let: Allows you to declare block-scoped variables, which means the variable is only available within the block it's defined in.<br>
                const: Declares block-scoped constants. Once a value is assigned to a const variable, it cannot be reassigned.</p><hr>
            <p>2. Arrow Functions:<br>
                Shorter syntax for writing functions using =>. They also do not bind their own this, 
                which makes them more predictable when dealing with object methods.</p><hr>
            <p>3. Template Literals:<br>
                Template literals allow for easier string interpolation and multi-line strings using backticks (```).</p><hr>
            <p>4. Default Parameters:<br>
                Allows you to set default values for function parameters if no arguments are provided or if undefined is passed.</p><hr>
            <p>5. Destructuring Assignment:<br>
                Enables the extraction of values from arrays or properties from objects into distinct variables.</p><hr>
            <p>6. Rest and Spread Operators:<br>
                .Rest (...): Collects all remaining elements into an array.<br>
                .Spread (...): Spreads out elements of an array or object.</p><hr>
            <p>7. Classes:<br>
                Introduces a new syntax for creating objects using class-based OOP (Object-Oriented Programming). Classes can include constructors, methods, and inheritance.
                </p><hr>
            <p>8. Modules:<br>
                ES6 introduces native support for modules, allowing you to import and export functionality between files.</p><hr>
        
            <p>9. Enhanced Object Literals:<br>
                Simplified syntax for initializing properties and methods within object literals.</p><hr>
            
            <p>10. Promises:<br>
                Provides a way to handle asynchronous operations, replacing the older callback approach. Promises can be chained and allow better error handling.
                </p>
        </div>

    </div><hr>
    <div class="part2">
        <h1>API in JavaScript</h1>
        <div class="content">
            <p>1. Using the XMLHttpRequest Object
                XMLHttpRequest (XHR) is an older way of making network requests in JavaScript. It provides a way to send HTTP requests and receive responses, 
                but it requires more code and is less intuitive than modern methods.<br>
                "Example:"<br>
                "function fetchDataWithXHR() {
                    const xhr = new XMLHttpRequest();
                    xhr.open("GET", "https://jsonplaceholder.typicode.com/posts/1", true);
                    xhr.onreadystatechange = function () {
                        if (xhr.readyState === 4 && xhr.status === 200) {
                            const response = JSON.parse(xhr.responseText);
                            console.log(response);
                        }
                    };
                    xhr.send();
                }
                
                fetchDataWithXHR();"
            </p><hr>
            <p>2. Using the fetch() API
                fetch() is a modern and more powerful API for making HTTP requests in JavaScript. 
                It returns a Promise and is easier to use and more versatile than XMLHttpRequest.<br>
                "Example:"<br>
                "function fetchDataWithFetch() {
                    fetch("https://jsonplaceholder.typicode.com/posts/1")
                        .then(response => {
                            if (!response.ok) {
                                throw new Error("Network response was not ok " + response.statusText);
                            }
                            return response.json();
                        })
                        .then(data => console.log(data))
                        .catch(error => console.error("There has been a problem with your fetch operation:", error));
                }
                
                fetchDataWithFetch();"
            </p><hr>
            <p>3. Using async/await with fetch()
                async/await is a syntactical sugar built on top of Promises, 
                making asynchronous code look and behave more like synchronous code. 
                This approach can make the code more readable and easier to manage.<br>
                "Example:"<br>
                "async function fetchDataWithAsyncAwait() {
                    try {
                        const response = await fetch("https://jsonplaceholder.typicode.com/posts/1");
                        if (!response.ok) {
                            throw new Error("Network response was not ok " + response.statusText);
                        }
                        const data = await response.json();
                        console.log(data);
                    } catch (error) {
                        console.error("There has been a problem with your fetch operation:", error);
                    }
                }
                
                fetchDataWithAsyncAwait();"
            </p>
        </div>
    </div>
</body>
</html>